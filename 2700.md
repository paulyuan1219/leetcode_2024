# 2762. Continuous Subarrays

## Soltion on 2024-10-21
This is introducted by meta portal.

The following approach is bottom up and should be correct, but exceed time limits

```python
class Solution:
    def continuousSubarrays(self, nums: List[int]) -> int:
        n = len(nums)

        if len(nums) < 2:
            return 1
        
        ht = {}
        ht[1] = [ (i, i, nums[i], nums[i]) for i in range(len(nums))]

        curr_size = 1
        result = 0

        while curr_size in ht and len(ht[curr_size]) > 0:
            # we already have some results with curr_size
            # now we need to explore if curr_size+1 exist
            result += len(ht[curr_size])

            ht[curr_size + 1] = []

            for start, end, low_limit, high_limit in ht[curr_size]:
                if end + 1 >= n:
                    break
                
                new_low_limit = min(low_limit, nums[end+1])
                new_high_limit = max(high_limit, nums[end+1])

                if new_high_limit - new_low_limit > 2:
                    continue
                
                # this is a valid subarray
                ht[curr_size + 1].append((start, end+1, new_low_limit, new_high_limit))
            
            del ht[curr_size]
            
            curr_size += 1
        
        return result
```

Let's try top down approach. But conceptually, it still takes too long.

The following code is not right

```python
class Solution:
    def continuousSubarrays(self, nums: List[int]) -> int:
        n = len(nums)

        if len(nums) < 2:
            return 1
        
        slow, fast = 0, 0
        window = {nums[0]:1}
        window_min, window_max = nums[0], nums[0]
        result = 0

        while True:
            fast += 1

            if fast == n:
                break

            new_min = min(window_min, nums[fast])
            new_max = max(window_max, nums[fast])

            if new_max - new_min <= 2:
                # this expansion is successful
                window_min, window_max = new_min, new_max
                if nums[fast] not in window:
                    window[nums[fast]] = 1
                else:
                    window[nums[fast]] += 1
                continue
            
            # here, we know that introducing nums[fast] will cause some bad element
            # here, (slow, fast-1) is valid
            result += self.helper(fast - slow)

            # we need to shrink the window
            while slow < fast:
                tmp_val = nums[slow]
                window[tmp_val] -= 1

                if window[tmp_val] == 0:
                    del window[tmp_val]
                
                if tmp_val == window_min and tmp_val not in window:
                    window_min = min(window.keys())
                
                if tmp_val == window_max and tmp_val not in window:
                    window_max = max(window.keys())
                
                slow += 1

                tmp_min = min(window_min, nums[fast])
                tmp_max = max(window_max, nums[fast])

                if tmp_max - tmp_min > 2:
                    continue
                else:
                    break
            
            # now, (slow, fast) is a valid stuff
            window_min, window_max = tmp_min, tmp_max
            if nums[fast] not in window:
                window[nums[fast]] = 1
            else:
                window[nums[fast]] += 1

        # once we are here, fast == n
        # which means (slow, fast-1) is valid
        result += self.helper(fast - slow)

        return result
    
    def helper(self, n):
        # get the sum of 1+2+...+n
        return n * (1 + n) // 2
```

Wrong Answer
Runtime: 30 ms
Case 1
Case 2
Input
nums =
[5,4,2,4]
Output
9
Expected
8

After debugging, I find a problem

- Given the array [5, 4, 2, 4], my solution will detect [5, 4] ==> 3 and [4, 2, 4] ==> 6, The final output is 9
- however, the [4] subarray is counted twice
- Need to find some way to handle this problem.
- 

A possible way is to only count sliding window with size >=2. Since unigram widow is trivial.
The following window is still not working
```python
class Solution:
    def continuousSubarrays(self, nums: List[int]) -> int:
        n = len(nums)

        if len(nums) < 2:
            return 1
        
        slow, fast = 0, 0
        window = {nums[0]:1}
        window_min, window_max = nums[0], nums[0]
        result = 0

        while True:
            fast += 1

            if fast == n:
                break

            new_min = min(window_min, nums[fast])
            new_max = max(window_max, nums[fast])

            if new_max - new_min <= 2:
                # this expansion is successful
                window_min, window_max = new_min, new_max
                if nums[fast] not in window:
                    window[nums[fast]] = 1
                else:
                    window[nums[fast]] += 1
                continue
            
            # here, we know that introducing nums[fast] will cause some bad element
            # here, (slow, fast-1) is valid
            result += self.helper(fast - slow)

            # we need to shrink the window
            while slow < fast:
                tmp_val = nums[slow]
                window[tmp_val] -= 1

                if window[tmp_val] == 0:
                    del window[tmp_val]
                
                if tmp_val == window_min and tmp_val not in window:
                    window_min = min(window.keys())
                
                if tmp_val == window_max and tmp_val not in window:
                    window_max = max(window.keys())
                
                slow += 1

                tmp_min = min(window_min, nums[fast])
                tmp_max = max(window_max, nums[fast])

                if tmp_max - tmp_min > 2:
                    continue
                else:
                    break
            
            # now, (slow, fast) is a valid stuff
            window_min, window_max = tmp_min, tmp_max
            if nums[fast] not in window:
                window[nums[fast]] = 1
            else:
                window[nums[fast]] += 1

        # once we are here, fast == n
        # which means (slow, fast-1) is valid
        result += self.helper(fast - slow)

        return result + n
    
    def helper(self, n):
        # get the sum of 1+2+...+ (n-1)
        return n * (n - 1) // 2

```

Wrong Answer
1531 / 2135 testcases passed
Input
nums =
[65,66,67,66,66,65,64,65,65,64]

Use Testcase
Output
46
Expected
43

