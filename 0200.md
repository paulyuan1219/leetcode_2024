# 200. Number of Islands

## Solution on 2024-10-22
trivial with bfs

```python
from collections import deque

delta = [[-1, 0], [1, 0], [0, -1], [0, 1]]

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m = len(grid)
        n = len(grid[0])
        visited = set()

        count = 0
        for r in range(m):
            for c in range(n):
                if not self.check(grid, m, n, r, c, visited):
                    continue
                
                self.bfs(grid, r, c, visited)
                count += 1

        return count


    def bfs(self, grid, row, col, visited):
        queue = deque([(row, col)])
        visited.add((row, col))
        m = len(grid)
        n = len(grid[0])

        while len(queue) > 0:
            for _ in range(len(queue)):
                r, c = queue.popleft()

                for dr, dc in delta:
                    r_, c_ = r + dr, c + dc

                    if not self.check(grid, m, n, r_, c_, visited):
                        continue
                    
                    # this is new land element
                    visited.add((r_, c_))
                    queue.append((r_, c_))
    
    def check(self, grid, m, n, r_, c_, visited):
        if r_ < 0 or r_ >= m:
            return False
        
        if c_ < 0 or c_ >= n:
            return False
        
        if grid[r_][c_] == '0':
            return False
        
        if (r_, c_) in visited:
            return False
        
        return True
```
# 215. Kth Largest Element in an Array

```python
import heapq

class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return self.quickSelect(nums, 0, len(nums) - 1, k)

    

    def quickSelect(self, nums, start, end, k):
        if start >= end:
            return nums[start]
        
        left, right = start, end
        pivot = nums[(left + right) // 2]

        while left <= right:
            while left <= right and nums[left] > pivot:
                left += 1
            
            while left <= right and nums[right] < pivot:
                right -= 1
            
            if left <= right:
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
                right -= 1
        
        if start + k - 1 <= right:
            return self.quickSelect(nums, start, right, k)
        elif start + k - 1 >= left:
            return self.quickSelect(nums, left, end, k - (left - start))
        else:
            return nums[right + 1]
                

        # heap = []

        # for num in nums:
        #     if len(heap) < k:
        #         heapq.heappush(heap, num)
        #         continue
            
        #     if heap[0] >= num:
        #         continue
            
        #     heapq.heappop(heap)
        #     heapq.heappush(heap, num)
        
        # return heap[0]
        
```


# 227. Basic Calculator II

## solution by Labuladong
有点难，需要理解。

```python
class Solution:
    def calculate(self, s: str) -> int:
        stk = []
        # 记录算式中的数字
        num = 0
        # 记录 num 前的符号，初始化为 +
        sign = "+"

        for i in range(len(s)):
            if s[i].isdigit():
                num = 10 * num + int(s[i])

            # 遇到 +,-,*,/ 或者到了最末尾
            if s[i] in "+-*/" or i == len(s) - 1:
                if sign == "+":
                    stk.append(num)
                elif sign == "-":
                    stk.append(-num)
                # 只要拿出前一个数字做对应运算即可
                elif sign == "*":
                    stk[-1] *= num
                else:
                    # 遇到除号，需要拿出前一个数字做除法
                    stk[-1] = int(stk[-1] / num)

                # 更新符号为当前符号，数字清零
                sign = s[i]
                num = 0

        # 将栈中所有结果求和就是答案
        return sum(stk)        
```

# 270. Closest Binary Search Tree Value

## solution on 2024-09-03

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def closestValue(self, root, target):
        """
        :type root: TreeNode
        :type target: float
        :rtype: int
        """
        self.res = root.val
        self.helper(root, target)
        return self.res
    
    def helper(self, root, target):
        if not root:
            return
        
        if abs(root.val - target) < abs(self.res - target):
            self.res = root.val
        elif abs(root.val - target) == abs(self.res - target):
            if root.val < self.res:
                self.res = root.val
        else:
            pass
        
        if abs(root.val - target) == 0:
            return
        
        if root.val < target:
            self.helper(root.right, target)
        else:
            self.helper(root.left, target)
```
