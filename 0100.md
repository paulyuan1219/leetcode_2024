# 1. Two Sum
Solved
Easy
Topics
Companies
Hint
Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

**Solution 1 on Mar 11, 2024** <br>
This is a trivial solution

```python
def twoSum(self, nums: List[int], target: int) -> List[int]:
    if len(nums) < 2:
        return []
    
    if len(nums) == 2:
        return [0, 1]

    for i in range(0, len(nums) - 1):
        for j in range(i + 1, len(nums)):
            if nums[i] + nums[j] == target:
                return [i, j]
    
    return []

```

**Solution 2 on Mar 11, 2024** <br>
This one uses hash table and is much faster. Two times scan with a hash map.

```python
def twoSum(self, nums: List[int], target: int) -> List[int]:
    if len(nums) < 2:
        return []
    
    if len(nums) == 2:
        return [0, 1]

    ht = {}
    for i in range(len(nums)):
        v = nums[i]
        if v not in ht:
            ht[v] = [i]
        else:
            ht[v].append(i)

    for i in range(0, len(nums)):
        compliment = target - nums[i]
        if compliment in ht:
            if compliment != nums[i]:
                return i, ht[compliment][0]
            
            if len(ht[compliment]) >= 2:
                return ht[compliment][0:2]
    
    return []
```

**Solution 3 on Mar 11, 2024** <br>
This is inspired by Hint 3. One scan with a hash table.

```python
def twoSum(self, nums: List[int], target: int) -> List[int]:
    if len(nums) < 2:
        return []
    
    if len(nums) == 2:
        return [0, 1]

    ht = {}
    for i in range(len(nums)):
        v = nums[i]
        complement = target - v
        if complement in ht:
            return [ht[complement], i]
        
        ht[v] = i
    
    return []
```


# 9. Palindrome Number
Solved
Easy
Topics
Companies
Hint
Given an integer x, return true if x is a 
palindrome, and false otherwise.

**Solution 1 on Mar 11, 2024** <br>
int ==> number array ==> string, then compare

```python
def isPalindrome(self, x: int) -> bool:
    if x < 0:
        return False
    
    if x < 10:
        return True
    
    arr = []
    while x >= 10:
        arr.append(str(x % 10))
        x = x // 10
    
    arr.append(str(x))

    s1 = ''.join(arr)
    s2 = ''.join(arr[::-1])

    return s1 == s2
```

Alternatively, we can check the Palindrome property by comparing two arrays of numbers directly.

```python
    start = 0
    end = len(arr) - 1

    while start < end:
        if arr[start] != arr[end]:
            return False
        start += 1
        end -= 1
    
    return True
```

# 15. 3Sum
Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

Notice that the solution set must not contain duplicate triplets.

 

Example 1:

Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
Example 2:

Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
Example 3:

Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.
 

Constraints:
- 3 <= nums.length <= 3000
- 105 <= nums[i] <= 105

## solution 1
this is a brute force way, and it's hard to rremove duplicates.

```python
def threeSum(self, nums: List[int]) -> List[List[int]]:
    if len(nums) < 3:
        return []
    
    ans = set()
    
    for i in range(len(nums) - 2):
        for j in range(i + 1, len(nums) - 1):
            for k in range(j + 1, len(nums)):
                if nums[i] + nums[j] + nums[k] == 0:
                    ans.add(sorted([nums[i], nums[j], nums[k]]))

    return list(ans)
```

```bash
TypeError: unhashable type: 'list'
    ans.add(sorted([nums[i], nums[j], nums[k]]))
Line 12 in threeSum (Solution.py)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ret = Solution().threeSum(param_1)
Line 33 in _driver (Solution.py)
    _driver()
Line 44 in <module> (Solution.py)
```

## solution 2 with helper of 2Sum
Time Limit Exceeded. Must exist some infinite loop hee.

```python
def threeSum(self, nums: List[int]) -> List[List[int]]:
    def helper(nums, start, end, target, ans):
        while start < end:
            tmp_sum = nums[start] + nums[end]

            if tmp_sum == -target:
                ans.append([target, nums[start], nums[end]])

                while start < end and nums[start + 1] == nums[start]:
                    start += 1
                
                while start < end and nums[end - 1] == nums[end]:
                    end -= 1
            elif tmp_sum < -target:
                while start < end and nums[start + 1] == nums[start]:
                    start += 1
            else:
                while start < end and nums[end - 1] == nums[end]:
                    end -= 1
                

    if len(nums) < 3:
        return []
    
    nums = sorted(nums)

    prev_num = None

    ans = []

    for i in range(len(nums) - 2):
        if nums[i] == prev_num:
            continue
        
        helper(nums, i + 1, len(nums) - 1, nums[i], ans)
```

After careful checking. find the infinite loop here. The helper function should be as follows. This one works fine. The overall idea is good. Nice done!!!

```python
    def helper(nums, start, end, target, ans):
        while start < end:
            tmp_sum = nums[start] + nums[end]

            if target + nums[start] + nums[end] == 0:
                ans.append([target, nums[start], nums[end]])

                start += 1
                while start < end and nums[start - 1] == nums[start]:
                    start += 1
                
                end -= 1
                while start < end and nums[end + 1] == nums[end]:
                    end -= 1
            elif target + nums[start] + nums[end] < 0:
                start += 1
                while start < end and nums[start - 1] == nums[start]:
                    start += 1
            else:
                end -= 1
                while start < end and nums[end + 1] == nums[end]:
                    end -= 1
```


# 20. Valid Parentheses
Solved
Easy
Topics
Companies
Hint
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.

**Solution 1 on Mar 11, 2024** <br>

```python
def isValid(self, s: str) -> bool:

    def helper(curr_char, top_char):
        if curr_char == ')':
            expected_char = '('
        elif curr_char == '}':
            expected_char = '{'
        elif curr_char == ']':
            expected_char = '['

        return expected_char == top_char

    stack = []
    for c in s:
        if c in ['(', '{', '[']:
            stack.append(c)
            continue
        
        if len(stack) == 0:
            return False
        
        if helper(c, stack.pop()):
            continue
        else:
            return False
    
    return len(stack) == 0
        

```