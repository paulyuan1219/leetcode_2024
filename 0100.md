# 114. Flatten Binary Tree to Linked List

## Solution on 2024-10-16
not hard, just do it in a recuisive way

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def flatten(self, root):
        """
        :type root: TreeNode
        :rtype: None Do not return anything, modify root in-place instead.
        """
        if not root:
            return
        
        self.flattenOneNode(root)

    def flattenOneNode(self, root):
        if root.left is None and root.right is None:
            return root, root

        left_head, left_tail = root, root
        if root.left:
            left_head, left_tail = self.flattenOneNode(root.left)


        right_head, right_tail = root, root
        if root.right:
            right_head, right_tail = self.flattenOneNode(root.right)

        if left_head != root and right_head != root:
            # both children exist
            root.left = None
            root.right = left_head
            left_tail.right = right_head
            return root, right_tail
        elif left_head != root:
            # only left child exists
            root.left = None
            root.right = left_head
            return root, left_tail
        else:
            # only right child exists
            root.left = None
            root.right = right_head
            return root, right_tail
```

# 121. Best Time to Buy and Sell Stock

## Solution on 2024-10-22
The following is the simplest solution, but it takes more memory

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)

        min_array = [0] * n
        max_array = [0] * n

        min_array[0] = prices[0]
        for i in range(1, n):
            min_array[i] = min(min_array[i-1], prices[i])
        
        max_array[n-1] = prices[n-1]
        for i in range(n-2, -1, -1):
            max_array[i] = max(max_array[i+1], prices[i])
        
        res = 0
        for i in range(n):
            res = max(res, max_array[i] - min_array[i])
        
        return res
```

# 124 Binary Tree Maximum Path Sum

## 2024-10-16 (Excellent)
First try is not successful. There's some error here

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        _, result = self.helper(root)
        return result
    
    def helper(self, root):
        if root.left is None and root.right is None:
            return root.val, root.val # the max_sum result of the tree of root, the max height including root to leaf node
        
        left_child_max_sum, left_child_max_height = 0, 0
        if root.left:
            left_child_max_sum, left_child_max_height = self.helper(root.left)
            
        right_child_max_sum, right_child_max_height = 0, 0
        if root.right:
            right_child_max_sum, right_child_max_height = self.helper(root.right)
        
        curr_node_max_sum = max(root.val + left_child_max_height + right_child_max_height, max(left_child_max_sum, right_child_max_sum))
        curr_node_max_height = root.val + max(left_child_max_height, right_child_max_height)
        return curr_node_max_sum, curr_node_max_height
```
Submission Result: Wrong Answer 
Input:
[1,2,3]
Output:
4
Expected:
6

Think about it, then modify it a bit. But still not right
```python
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        result, _ = self.helper(root)
        return result
    
    def helper(self, root):
        if root.left is None and root.right is None:
            return root.val, root.val # the max_sum result of the tree of root, the max height including root to leaf node
        
        left_child_max_sum, left_child_max_height = 0, 0
        if root.left:
            left_child_max_sum, left_child_max_height = self.helper(root.left)
            
        right_child_max_sum, right_child_max_height = 0, 0
        if root.right:
            right_child_max_sum, right_child_max_height = self.helper(root.right)
        
        # find curr node max sum
        curr_node_max_sum = max( \
                                left_child_max_sum, \
                                right_child_max_sum, \
                                root.val, \
                                root.val + left_child_max_height, \
                                root.val + right_child_max_height, \
                                root.val + left_child_max_height + right_child_max_height \
                               )
        
        curr_node_max_height = max( \
                                   root.val, \
                                   root.val + left_child_max_height, \
                                   root.val + right_child_max_height \
                                  )
        return curr_node_max_sum, curr_node_max_height
```
Submission Result: Wrong Answer 
Input:
[-2,-1]
Output:
0
Expected:
-1

Hahaha, update the initial value is successful


**Key Idea**
- For each node, two values are returned
  - The first one is the best result (or max sum path) of the tree with this node as root. It may or may not contain this node.
  - The second one is the best vertical path including the current node.
- For the first returned value, we need to consider multiple conditions
  - If root is not included in the best path, then we need to choose between left_child_max_sum and right_child_max_sum
  - If root is included in the best path, then we need to consider 4 options
- For the second returned value, we need to consider 3 options.
- As long as these options are clear, then it's easy understand everything.

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        result, _ = self.helper(root)
        return result
    
    def helper(self, root):
        if root.left is None and root.right is None:
            return root.val, root.val # the max_sum result of the tree of root, the max height including root to leaf node
        
        left_child_max_sum, left_child_max_height = float("-inf"), float("-inf")
        if root.left:
            left_child_max_sum, left_child_max_height = self.helper(root.left)
            
        right_child_max_sum, right_child_max_height = float("-inf"), float("-inf")
        if root.right:
            right_child_max_sum, right_child_max_height = self.helper(root.right)
        
        # find curr node max sum
        curr_node_max_sum = max( \
                                left_child_max_sum, \
                                right_child_max_sum, \
                                root.val, \
                                root.val + left_child_max_height, \
                                root.val + right_child_max_height, \
                                root.val + left_child_max_height + right_child_max_height \
                               )
        
        curr_node_max_height = max( \
                                   root.val, \
                                   root.val + left_child_max_height, \
                                   root.val + right_child_max_height \
                                  )
        return curr_node_max_sum, curr_node_max_height
```

# 133. Clone Graph

## Solution on 2024-10-22
Not hard. Just need to be careful

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""

from typing import Optional
from collections import deque

class Solution:
    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:
        if not node:
            return None
        
        # get all nodes
        old_graph_nodes = self.getNodeHashtable(node)

        # create all nodes
        self.createNodeSet(old_graph_nodes)

        # create all edges
        self.createEdges(old_graph_nodes)

        return old_graph_nodes[node]
    
    def createEdges(self, old_graph_nodes):
        for old_start in old_graph_nodes.keys():
            new_start = old_graph_nodes[old_start]

            for old_neighbor in old_start.neighbors:
                new_neighbor = old_graph_nodes[old_neighbor]
                new_start.neighbors.append(new_neighbor)


    def createNodeSet(self, old_graph_nodes):
        for n in old_graph_nodes.keys():
            old_graph_nodes[n] = Node(n.val)


    def getNodeHashtable(self, node):
        # return a set of all nodes
        visited = {node:None}
        queue = deque([node])
        
        while len(queue) > 0:
            for _ in range(len(queue)):
                n = queue.popleft()

                for neighbor in n.neighbors:
                    if neighbor in visited:
                        continue
                    
                    visited[neighbor] = None
                    queue.append(neighbor)
        
        return visited
```
# 138. Copy List with Random Pointer

## Solution on 2024-10-22
This is exactly the same as problem 133 Clone Graph. we can just use the previous solution with minor modification

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random
"""
from collections import deque

class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        node = head

        if not node:
            return None
        
        # get all nodes
        old_graph_nodes = self.getNodeHashtable(node)

        # create all nodes
        self.createNodeSet(old_graph_nodes)

        # create all edges
        self.createEdges(old_graph_nodes)

        return old_graph_nodes[node]
    
    def createEdges(self, old_graph_nodes):
        for old_start in old_graph_nodes.keys():
            new_start = old_graph_nodes[old_start]

            if old_start.next:
                new_start.next = old_graph_nodes[old_start.next]
            
            if old_start.random:
                new_start.random = old_graph_nodes[old_start.random]


    def createNodeSet(self, old_graph_nodes):
        for n in old_graph_nodes.keys():
            old_graph_nodes[n] = Node(n.val)


    def getNodeHashtable(self, node):
        # return a set of all nodes
        visited = {node:None}
        queue = deque([node])
        
        while len(queue) > 0:
            for _ in range(len(queue)):
                n = queue.popleft()

                if n.next and n.next not in visited:
                    visited[n.next] = None
                    queue.append(n.next)
                
                if n.random and n.random not in visited:
                    visited[n.random] = None
                    queue.append(n.random)
        
        return visited        
```

# 153. Find Minimum in Rotated Sorted Array
Medium
Topics
Companies
Hint
Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:

[4,5,6,7,0,1,2] if it was rotated 4 times.
[0,1,2,4,5,6,7] if it was rotated 7 times.
Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].

Given the sorted rotated array nums of unique elements, return the minimum element of this array.

You must write an algorithm that runs in O(log n) time.

 

Example 1:

Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.
Example 2:

Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
Example 3:

Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times. 
 

Constraints:

n == nums.length
1 <= n <= 5000
-5000 <= nums[i] <= 5000
All the integers of nums are unique.
nums is sorted and rotated between 1 and n times.

## solution on Mar 21, 2024

The following code provides wrong ans.

```python
class Solution(object):
    def findMin(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        
        start, end = 0, len(nums) - 1

        while start + 1 < end:
            mid = (start + end) // 2

            if nums[start] < nums[mid]:
                if nums[start] < nums[end]:
                    return nums[start]
                else:
                    start = mid
            else: # indicates nums[mid] < nums[end]
                if nums[mid] < nums[start]:
                    return nums[mid]
                else:
                    end = mid
        
        return min(nums[start], nums[end])
```

```bash
nums = [5,1,2,3,4]
output: 2
expected: 1
```

Though this example, it's obvious that the code above is wrong. The judging criteria is not that simple.

The following code is accepted

```python
class Solution(object):
    def findMin(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        
        start, end = 0, len(nums) - 1

        while start + 1 < end:
            mid = (start + end) // 2

            # this is a trivial case
            if nums[start] < nums[mid] and nums[mid] < nums[end]:
                return nums[start]
            
            if nums[start] < nums[mid]:
                start = mid
            else: # indicates nums[mid] < nums[end]
                end = mid
        
        return min(nums[start], nums[end])
```

Below is my thought
- Case 1: if the whole array is strictly increasing, we will have `nums[start] < nums[mid] < nums[end]`. In this case, `nums[start]` is the minimal value.
- Case 2: if the whole array is rotated somewhere, then the whole array look like the follows. In this case, we can check `mid` value. If `mid` is located on the first line, this means that the minimum will be of the 2nd half. If `mid` is located on the 2nd line, then the minimum will be on the 1st half. That's simple.

```bash
    /
   /
  /
 /
s
       e
      /
     /
```

The code can be further optimized as follows:

```python
        while start + 1 < end:
            # this is a trivial case
            if nums[start] < nums[end]:
                return nums[start]

            mid = (start + end) // 2

            if nums[start] < nums[mid]:
                start = mid
            else: # indicates nums[mid] < nums[end]
                end = mid
        
        return min(nums[start], nums[end])
```


# 162. Find Peak Element
Medium
Topics
Companies
A peak element is an element that is strictly greater than its neighbors.

Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.

You may imagine that nums[-1] = nums[n] = -âˆž. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.

You must write an algorithm that runs in O(log n) time.

 

Example 1:

Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
Example 2:

Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.
 

Constraints:

1 <= nums.length <= 1000
-231 <= nums[i] <= 231 - 1
nums[i] != nums[i + 1] for all valid i.

## Solution on Mar 19, 2024.

The first try doesn't work. Time exceeded

```python
    def findPeakElement(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if len(nums) == 1:
            return 0

        start, end = 0, len(nums) - 1

        while start + 1 < end:
            mid = (start + end) // 2

            # we should check if mid is a peak location

            if nums[mid - 1] > nums[mid]:
                end = mid
            else:
                start = mid - 1 # this part is questionable., should be start = mid
        
        if start == 0 and nums[start] > nums[start + 1]:
            return start
        
        if end == len(nums) - 1 and nums[end] > nums[end - 1]:
            return end
        
        if nums[start - 1] < nums[start] and nums[start] > nums[start + 1]:
            return start
        
        if nums[end - 1] < nums[end] and nums[end] > nums[end + 1]:
            return end
```

Below is a quick fix. The idea is straigtfoward. Just do it.

```python
    def findPeakElement(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if len(nums) == 1:
            return 0

        start, end = 0, len(nums) - 1

        while start + 1 < end:
            mid = (start + end) // 2

            # this following `if` can be commented out. It's still correct.
            if nums[mid] > nums[mid - 1] and nums[mid] > nums[mid + 1]:
                return mid

            if nums[mid - 1] > nums[mid]:
                end = mid
            else:
                start = mid
        
        if start == 0 and nums[start] > nums[start + 1]:
            return start
        
        if end == len(nums) - 1 and nums[end] > nums[end - 1]:
            return end
        
        if nums[start - 1] < nums[start] and nums[start] > nums[start + 1]:
            return start
        
        if nums[end - 1] < nums[end] and nums[end] > nums[end + 1]:
            return end
```
## Solution on 2024-10-22
A simple binary search is good. not that hard

```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        n = len(nums)
        start, end = 0, n-1

        while start + 1 < end:
            mid = (start + end) // 2

            if nums[mid] > nums[mid-1]:
                start = mid
            else:
                end = mid
        
        if nums[start] > nums[end]:
            return start
        return end
```


# 173. Binary Search Tree Iterator
## Solution on 2024-10-22
Think out by myself. not bad

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class BSTIterator:

    def __init__(self, root: Optional[TreeNode]):
        self.stack = []

        node = root

        while node:
            self.stack.append(node)
            node = node.left
        

    def next(self) -> int:
        node = self.stack[-1]
        result = node.val

        if node.right:
            node = node.right
            while node:
                self.stack.append(node)
                node = node.left
        else:
            node = self.stack.pop()

            while len(self.stack) > 0 and self.stack[-1].right == node:
                node = self.stack.pop()

        return result
        

    def hasNext(self) -> bool:
        return len(self.stack) > 0
```
